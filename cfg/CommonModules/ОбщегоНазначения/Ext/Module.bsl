// Функция выделяет первое слово в предложении
Функция ВыделитьСлово(ИсходнаяСтрока) Экспорт
	
	Буфер = СокрЛ(ИсходнаяСтрока);
	ПозицияПослПробела = Найти(Буфер, " ");

	Если ПозицияПослПробела = 0 Тогда
		ИсходнаяСтрока = "";
		Возврат Буфер;
	КонецЕсли;
	
	ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));
	ИсходнаяСтрока  = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);
	
	Возврат ВыделенноеСлово;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, ЦелоеЧисло) Экспорт
 	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;

	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции
 
// функция из исходной строки формирует строку для поиска данных в запросе
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");

	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "", КодЯзыка = Неопределено) Экспорт	

	
    Если КодЯзыка = Неопределено Тогда
		КодЯзыка = Локализация.КодЯзыкаИнтерфейса();
	КонецЕсли;	
	
	ДатаДока = ДокументОбъект.Дата;
	
	Если ТипЗнч(ДокументОбъект) <> Тип("ВыборкаИзРезультатаЗапроса") 		
	  И ТипЗнч(ДокументОбъект) <> Тип("Структура") Тогда
		
		МетаданныеДокумента = ДокументОбъект.Метаданные();		
		Если МетаданныеДокумента.Реквизиты.Найти("ДатаВходящегоДокумента") <> Неопределено Тогда 
			Если ЗначениеЗаполнено(ДокументОбъект.ДатаВходящегоДокумента) Тогда
				ДатаДока = ДокументОбъект.ДатаВходящегоДокумента;		
			КонецЕсли;
		КонецЕсли;
		
	конецЕсли;
	
	
	Если ДокументОбъект = Неопределено Тогда
		Возврат "";
	Иначе
	Возврат ?(НЕ ЗначениеЗаполнено(НазваниеДокумента), МетаданныеДокумента.Синоним, НазваниеДокумента ) + " № " + ПолучитьНомерНаПечать(ДокументОбъект)

							+ НСтр("ru=' от ';uk=' від '",КодЯзыка) + Формат(ДатаДока, "ДФ='дд ММММ гггг';Л="+ Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка));
    КонецЕсли;

КонецФункции // СформироватьЗаголовокДокумента()

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта, КодЯзыка = "ru") Экспорт	

	
	ПараметрыПрописи = Локализация.ПараметрыПрописи(Валюта, КодЯзыка); 
	Если ПараметрыПрописи = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма,"Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка),ПараметрыПрописи);
	КонецЕсли;

КонецФункции // СформироватьСуммуПрописью()

Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
 
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	 Если МетаданныеДокумента.Реквизиты.Найти("Организация") = Неопределено
	 Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		Префикс = "0";                                         

	Иначе

		Префикс = ДокументОбъект.Организация.Префикс;

	КонецЕсли;
 
Конецпроцедуры

Процедура ПриУстановкеНовогоКодаСправочникаПриУстановкеНовогоКода(Источник, СтандартнаяОбработка, Префикс) Экспорт
 
	ДобавитьПрефиксУзла(Префикс);
	
 
КонецПроцедуры

// Формирует список обособленных структурных подразделений организации
Функция ПолучитьСписокОбособленныхПодразделенийОрганизации(Организация) Экспорт

	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &Организация");

	Запрос.УстановитьПараметр("Организация", Организация);

	СписокОрганизаций = Новый СписокЗначений;
	
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;
КонецФункции // ПолучитьСписокОбособленныхПодразделенийОрганизации()

// Преобразовывает число, строку (числовую) в число, Истина в 1, Ложь в 0, остальные значения (Null, Неопределено, другие значения) в 0 
//
// Параметры:
//	Значение - Значение, которое необходимо преобразовать в число
//
// Возвращаемое значение:
// Число, полученное в результате преобразования
//
Функция ПреобразоватьВЧисло(Значение) Экспорт
	
	Если (Значение = Null) или (Значение = Неопределено) Тогда
		Возврат 0;
	Иначе
		Попытка
			Возврат Число(Значение);
		Исключение
			Возврат 0;
		КонецПопытки
	КонецЕсли;
	
КонецФункции // ПреобразоватьВЧисло()

Функция РазложитьЧислоВСтроку(Значение,Длина,ЛидирующиеНули=Ложь) Экспорт
	
	ФорматнаяСтрока = "ЧЦ="+Строка(Длина)+"; ЧДЦ=0; ЧГ=0";
	Если ЛидирующиеНули Тогда
		Строка0 = "0";
		Для Сч = 2 по Длина Цикл
			Строка0 = Строка0+"0";
		Конеццикла;
		ФорматнаяСтрока = ФорматнаяСтрока + "; ЧН="+Строка0+"; ЧВН=";
	Иначе
		ФорматнаяСтрока = ФорматнаяСтрока + "; ЧН=0";
	КонецЕсли;
	
	Результат = Формат(Значение,ФорматнаяСтрока);
	
	Если НЕ ЛидирующиеНули Тогда
		
		Пока СтрДлина(Результат) < Длина Цикл
			Результат = " "+Результат;
		КонецЦикла;	
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(ПустаяСтрока(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(ПустаяСтрока(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если Валюта <> Неопределено Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

// Функция предназначена для формирования массива префиксов.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция ПолучитьМассивПрефиксовРИБ() Экспорт
	
	МассивПрефиксов = Новый Массив();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	               |ИЗ
	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Функция предназначена для формирования массива префиксов.
//
// Параметры:
//  Организация - (СправочникСсылка), дял которой нужно получить префиксы.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
	
	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();	
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			МассивПрефиксов.Добавить(Префикс);
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Попытка                                      
		Если Документ.Метаданные().Реквизиты.Найти("НомерВходящегоДокумента") <> Неопределено Тогда 	
			Если ЗначениеЗаполнено(Документ.НомерВходящегоДокумента) Тогда
				Номер = СокрЛП(Документ.НомерВходящегоДокумента);
			Иначе
				Номер = СокрЛП(Документ.Номер);
			КонецЕсли;
		Иначе
			Номер = СокрЛП(Документ.Номер);
		КонецЕсли;
	Исключение
		Номер = СокрЛП(Документ.Номер);
	КонецПопытки;
	
	Если МассивПрефиксов = Неопределено Тогда
		Организация = Неопределено;

		Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
			ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда
			
			Организация = Документ.Организация;
			
		Иначе

			МетаданныеДокумента = Документ.Метаданные();

			Если МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено Тогда

				Организация = Документ.Организация;
				
			КонецЕсли;

		КонецЕсли;
		
		МассивПрефиксов = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация);
					
	КонецЕсли;

	Для Каждого ТекущийПрефикс ИЗ МассивПрефиксов Цикл
		
		// удаление префикса из номера документа
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;

	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

// Предназначена для получения запросом представлений объектов
// Поддерживает два синтаксиса
// 1.
// Параметры:
//	СсылкиОбъектовПарам - массив ссылок
// Возвращаемое значение
//	Соответствие в котором ключ - одна из переданных ссылок, 
//  а значение - представление этой ссылки
// 2. 
// Параметры:
//	СсылкиОбъектовПарам - ссылка
// Возвращаемое значение
//	Строка предсатвления ссылки
//
// Пример использования:
// 	МассивСсылок = Новый Массив;
// 	МассивСсылок.Добавить(НоваяОрганизация);
// 	МассивСсылок.Добавить(СтараяОрганизация);
// 	Представления = ПолучитьПредставленияОбъектов(МассивСсылок);
//	НоваяОрганизацияСтрокой = Представления[НоваяОрганизация];
//	СтараяОрганизацияСтрокой = Представления[СтараяОрганизация];
//
Функция ПолучитьПредставленияОбъектов(СсылкиОбъектовПарам) Экспорт
	// соответствие возвращается если передан массив ссылок
	ПереданМассив = Истина;
	
	// Если передано одиночное значение - "превратим" его в массив
	Если ТипЗнч(СсылкиОбъектовПарам) <> Тип("Массив") Тогда
		Ссылка = СсылкиОбъектовПарам;
		СсылкиОбъектов = Новый Массив;
		СсылкиОбъектов.Добавить(Ссылка);
		ПереданМассив = Ложь;
		
	Иначе
		СсылкиОбъектов = СсылкиОбъектовПарам;
		
	КонецЕсли;
	
	// Обработаем массив СсылкиОбъектов и сформируем 
	// соответствие ссылок по их типам
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
		ПолноеИмя = СсылкаНаОбъект.Метаданные().ПолноеИмя();
		Если СсылкиПоТипам[ПолноеИмя] = НеОпределено Тогда
			СсылкиПоТипам[ПолноеИмя] = Новый Массив;
		КонецЕсли;
		СсылкиПоТипам[ПолноеИмя].Добавить(СсылкаНаОбъект);
	КонецЦикла;
	
	// формирование запроса
	ТекстЗапроса = "";
	Запрос = Новый Запрос;
	ПервоеЗначение = Истина;
	Для Каждого ЭлементСоответствия Из СсылкиПоТипам Цикл
		ИмяПараметра = "Массив" + СтрЗаменить(ЭлементСоответствия.Ключ, ".", "_");
		Если Не ПервоеЗначение Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|ОБЪЕДИНИТЬ ВСЕ";
			
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "
		|ВЫБРАТЬ 
		|	Ссылка КАК Ссылка,
		|	ПРЕДСТАВЛЕНИЕ(Ссылка) КАК Представление
		|ИЗ " + ЭлементСоответствия.Ключ + "
		|ГДЕ Ссылка В (&" + ИмяПараметра + ")";
		Запрос.УстановитьПараметр(ИмяПараметра, ЭлементСоответствия.Значение);
		ПервоеЗначение = Ложь;
	КонецЦикла;
	// обработка запроса
	Запрос.Текст = ТекстЗапроса;
	Выборка = Запрос.Выполнить().Выбрать();
	Если ПереданМассив Тогда
		ВозвращаемоеСоответствие = Новый Соответствие;
		Пока Выборка.Следующий() Цикл
			ВозвращаемоеСоответствие[Выборка.Ссылка] = Выборка.Представление;
		КонецЦикла;
		
		// дополним пустыми представлениями неполученных запросом ссылок
		Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
			Если ВозвращаемоеСоответствие[СсылкаНаОбъект] = НеОпределено Тогда
				ВозвращаемоеСоответствие[СсылкаНаОбъект] = "";
			КонецЕсли;
			
		КонецЦикла;
		Возврат ВозвращаемоеСоответствие;
		
	Иначе
		Если Выборка.Следующий() Тогда
			Возврат Выборка.Представление;
		Иначе
			// если ссылки не нашлось - пустое представление
			Возврат "";
		КонецЕсли;
		
	КонецЕсли; 
	
КонецФункции

Функция ЭтоДоступнаяОрганизация(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ПометкаУдаления
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	
	Возврат Не Запрос.Выполнить().Пустой() // если удалось прочитать закрытое поле - организация доступна
	
КонецФункции // ЭтоДоступнаяОрганизация()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА

// Вспомогательная функция для определнения условий запроса в механизме
// изменения порядка следования элементов. Ставит условия на родителя и владельца
//
// Параметры
//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
//  Запрос - Запрос, в который дописываем условия
// 
//  Возвращаемое значение:
//   Строка - условие запроса
// 
Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)

	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 

	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает значение порядка для нового элемента справочника.
//
// Параметры
//  ЭлементОбъект - СправочникОбъект - новый объект
//
// Возвращаемое значение:
//   Число - новый порядок
//
Функция НазначитьНовыйПорядок(ЭлементОбъект)

	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат (Выборка.Порядок + 1)
	КонецЕсли; 

КонецФункции

// Процедура вызывается перед записью объекта, для которого необходимо
// контролировать порядок элементов.
// 
// Параметры
//  Отказ - Булево, отказ от записи объекта
//  ЭтотОбъект - СправочникОбъект
//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
//
Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт

	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
	
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			#Если Клиент Тогда
				Сообщить(НСтр("ru='Не уникальный порядок элемента справочника.';uk='Не унікальний порядок елемента довідника.'"));
			#КонецЕсли
		КонецЕсли;
	
	КонецЕсли; 

КонецПроцедуры

// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
// порядком следования.
// 
// Параметры:
//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
	
	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
	
	Если ЭлементЗамены = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
	
	Если НаправлениеПорядка = "Вверх" Тогда
		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
		КонецЕсли; 
	Иначе
		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	ФиксироватьТранзакцию = Истина;
	
	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
		ОбъектЗамены.КонтролироватьПорядок = Ложь;
		Попытка
			ОбъектЗамены.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Если ФиксироватьТранзакцию Тогда
		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
		Попытка
			ОбъектЭлемента.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ФиксироватьТранзакцию Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли; 
	
КонецПроцедуры

// Функция определяет элемент справочника, с которым необходимо
// произвести "рокировку" текущего элемента
//
// Параметры
//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
// Возвращаемое значение:
//   СправочникСсылка
//
Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)

	ТекущийПорядок = ЭлементСсылка.Порядок;
	
	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
		
	ИначеЕсли ЦиклическийСдвиг Тогда
		// Текущий элемент или первый (при движении вверх)
		// или последний (при движении вниз)
		// или вообще единственный
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Ссылка
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
		|УПОРЯДОЧИТЬ ПО
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Неопределено;
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	ИначеЕсли ЗаданныйТип = ТипЗнч(Неопределено) Тогда
		Возврат Неопределено;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//



// Позволяет определить есть ли среди реквизитов шапки отчета
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита     - строковое имя искомого реквизита, 
//  МетаданныеОтчета - метаданные отчета, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//



// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЕсли; 

	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = НСтр("ru='Не заполнены настройки для отправки сообщения.';uk='Не заповнені настройки для відправлення повідомлення.'");
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке(НСтр("ru='Не указан ""';uk='Не зазначений ""'") + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли;
	
	ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8.0 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8.0: " + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная));

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//	Класс  - класс
//	Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // ПринадлежностьКлассуМетаданных()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ

//Функция возвращает список доступных назначений для "Свойств и категорий объектов" 
//по переданной ссылке
// Параметры:
//	Ссылка - Ссылка на справочник или документ
//
// Возвращаемое значение:
// Список значений: доступные назначения для свойств и категорий
Функция ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(Ссылка) Экспорт

	Результат = Новый СписокЗначений;

	ТипСсылки = ТипЗнч(Ссылка);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);

	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Назначения.Ссылка КАК Ссылка,
	|	Назначения.ТипЗначения КАК ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	|ГДЕ
	|	НЕ Назначения.ЭтоГруппа
	|";

	ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка <> &НазначениеХарактеристика
		|";


	Запрос.Текст = ТекстЗапроса;

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если Выборка.ТипЗначения.СодержитТип(ТипСсылки) Тогда
			Результат.Добавить(Выборка.Ссылка);
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;


КонецФункции // ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Сообщить(НСтр("ru='Неверный тип универсальной коллекции для копирования';uk='Невірний тип універсальної колекції для копіювання'"));
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С СООБЩЕНИЯМИ ОШИБКАМИ

Функция ОпределитьВажностьСобытияЖурналаРегистрации(Статус)
	ВидСобытия = УровеньЖурналаРегистрации.Информация;
	Если Статус = СтатусСообщения.Внимание Тогда
		ВидСобытия = УровеньЖурналаРегистрации.Предупреждение;
	ИначеЕсли Статус = СтатусСообщения.Важное или  Статус = СтатусСообщения.ОченьВажное Тогда
		ВидСобытия = УровеньЖурналаРегистрации.Ошибка;
	КонецЕсли;
    Возврат  ВидСобытия;
КонецФункции

Процедура ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок="")
	ДублироватьСообщенияВЖурналРегистрации = глЗначениеПеременной("ДублироватьСообщенияВЖурналРегистрации");; 
	Если не ДублироватьСообщенияВЖурналРегистрации Тогда
		Возврат;
	КонецЕсли;
	Важность = ОпределитьВажностьСобытияЖурналаРегистрации(Статус);
	Если Заголовок<>"" Тогда
		//вывод заголовка как отдельной записи в журнал
		ЗаписьЖурналаРегистрации("Сообщение", УровеньЖурналаРегистрации.Примечание, , ,Заголовок);
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации("Сообщение", Важность, , ,ТекстСообщения);

КонецПроцедуры

// Процедура выводит пользователю сообщение.
//
// Параметры:
//	ТекстСообщения - Строка - Текст сообщения
//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
//		   - СтатусСообщения - Статус сообщения (используется для замены вызова процедуры Сообщить)
//	Заголовок - Строка - Текст заголовка
//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
//						 - Ссылка - Ссылка на объект
//	СтрокаРодитель - Родительская строка дерева значений для вывода сообщения
//	РаскрытьСообщение - Булево - Признак раскрытия строки дерева сообщений
//
// Возвращаемое значение:
//	СтрокаДереваЗначенний - Строка дерева значений, в которую записано текущее сообщение
//
Функция Сообщение(Знач ТекстСообщения, Статус = Неопределено, Заголовок = "", РасшифровкаСообщения = Неопределено, СтрокаРодитель = Неопределено, РаскрытьСообщение = Истина) Экспорт
	

	ВыводитьСообщенияВПанельКомментариев = Ложь;

	
	Если ВыводитьСообщенияВПанельКомментариев Тогда
		Если ТипЗнч(Статус) = Тип("ПеречислениеСсылка.ВидыСообщений") Тогда
			ВидСообщения = Статус;
		Иначе
			Если Статус = СтатусСообщения.Внимание Тогда
				ВидСообщения = Перечисления.ВидыСообщений.ВажнаяИнформация;
			ИначеЕсли Статус = СтатусСообщения.Важное Тогда
				ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
			Иначе
				ВидСообщения = Перечисления.ВидыСообщений.Информация;
			КонецЕсли;
		КонецЕсли;
		
		ФормаОбработкиКомментариев = Обработки.СообщенияВыполняемыхДействий.ПолучитьФорму();
		Если ФормаОбработкиКомментариев.Открыта() Тогда
			ОбработкаКомментариев = ФормаОбработкиКомментариев.ОбработкаОбъект;
		Иначе
			ОбработкаКомментариев = Обработки.СообщенияВыполняемыхДействий.Создать();
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ОбработкаКомментариев.ДобавитьСообщение(Заголовок, Перечисления.ВидыСообщений.Раздел);
			Заголовок = "";
		КонецЕсли;
		
		Если ТипЗнч(РасшифровкаСообщения) = Тип("Массив") Тогда
			Расшифровка = РасшифровкаСообщения;
			
		ИначеЕсли РасшифровкаСообщения <> Неопределено Тогда
			МассивРасшифровки = Новый Массив;
			МассивРасшифровки.Добавить(РасшифровкаСообщения);
			
			СтруктураРасшифровки = Новый Структура;
			СтруктураРасшифровки.Вставить("Представление", " (открыть)");
			СтруктураРасшифровки.Вставить("Расшифровка", РасшифровкаСообщения);
			
			Расшифровка = Новый Массив;
			Расшифровка.Добавить(СтруктураРасшифровки);
			
		Иначе
			Расшифровка = Неопределено;
		КонецЕсли;
		
		СтрокаДереваЗначенний = ОбработкаКомментариев.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровка, СтрокаРодитель, РаскрытьСообщение);
		ОбработкаКомментариев.ПоказатьСообщения();
	
	Иначе
	
		СтрокаДереваЗначенний = Неопределено;	
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Если ТипЗнч(Статус) = Тип("СтатусСообщения") Тогда
			Сообщить(ТекстСообщения, Статус);
		Иначе
			Сообщить(ТекстСообщения);
		КонецЕсли;
	
	КонецЕсли;

    Возврат СтрокаДереваЗначенний;
	
КонецФункции // Сообщение()

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()
                                                                          
// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//	Заголовок - Строка - Текст заголовка
//	Статус - СтатусСообщения - Статус сообщения
//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
//						 - Ссылка - Ссылка на объект
//
Процедура СообщитьОбОшибке(
	Знач ТекстСообщения, 
	Отказ = Ложь, 
	Заголовок = "",
	Статус = Неопределено,
	РасшифровкаСообщения = Неопределено
	) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);

	Отказ = Истина;
	#Если не Клиент Тогда
		//Для клиента запись в журнал регистрации попадет внутри процедуры Сообщение
	#КонецЕсли

	#Если ВнешнееСоединение Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#ИначеЕсли Клиент Тогда
		
		Сообщение(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, Неопределено, Истина);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Источник - структура шапки или ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа
//
Функция ПредставлениеДокументаПриПроведении(Источник) Экспорт
	
	Если ТипЗнч(Источник) = Тип("Структура") Тогда
		ПредставлениеДокумента = Источник.ПредставлениеДокумента;
		Если Источник.Свойство("ВидОперации") Тогда
			ПредставлениеДокумента = ПредставлениеДокумента + " (" + Источник.ВидОперации + ")";
		КонецЕсли; 
	Иначе
		МетаданныеДокумента = Источник.Метаданные();
		ВидОперацииСтр = "";
		Если МетаданныеДокумента.Реквизиты.Найти("ВидОперации") <> Неопределено Тогда
			ВидОперацииСтр = " (" + Источник.ВидОперации + ")";
		КонецЕсли;
		ПредставлениеДокумента = СокрЛП(Источник) + ВидОперацииСтр;
	КонецЕсли; 
	
	ПредставлениеДокумента = НСтр("ru='Проведение документа: ';uk='Проведення документа: '") + ПредставлениеДокумента;
	
	Возврат ПредставлениеДокумента;
	
КонецФункции // ПредставлениеДокументаПриПроведении

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	
	Перем Упр, Бух, Нал;
	
	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
	ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете", Нал);
	
	Если ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал Тогда
		Если НЕ МожетБытьТолькоНалоговый Тогда
			Если Упр <> Истина И Бух <> Истина  Тогда
				СообщитьОбОшибке(НСтр("ru='Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".';uk='Документ повинен належати хоча б одному з видів обліку: ""Управлінський"" і (або) ""Бухгалтерський"".'"), Отказ, Заголовок);
			ИначеЕсли Бух <> Истина И Нал = Истина Тогда
				СообщитьОбОшибке(НСтр("ru='Документ не может проводиться  по налоговому учету, если он не проводится по бухгалтерскому учету.';uk='Документ не може проводитися по податковому обліку, якщо він не проводиться по бухгалтерському обліку.'") , Отказ, Заголовок);
			КонецЕсли;
		Иначе
			Если Упр <> Истина И Бух <> Истина И Нал <> Истина Тогда
				СообщитьОбОшибке(НСтр("ru='Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"", ""Бухгалтерский"", ""Налоговый"".';uk='Документ повинен належати хоча б одному з видів обліку: ""Управлінський"", ""Бухгалтерський"", ""Податковий"".'"), Отказ, Заголовок);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

// Выводит информационное сообщение
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - строка, заголовок.
//  Статус         - СтатусСообщения
//
Процедура СообщитьИнформацию(ТекстСообщения, Заголовок = "", Статус = Неопределено) 

	#Если Клиент Тогда
		
		Если Статус = Неопределено Тогда
			Статус = СтатусСообщения.Информация;
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьИнформацию()

// Выводит служебное информационное сообщение, если глЗначениеПеременной("ВыводитьСлужебнуюИнформацию") = Истина
// Предназначена для выдачи различных отладочных сообщений 
// Для установки глобальной переменной "ВыводитьСлужебнуюИнформацию" в Истина запускаем с параметром запуска "test"
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - строка, заголовок.
//  Статус         - СтатусСообщения
//
Процедура СообщитьСлужебнуюИнформацию(ТекстСообщения, Заголовок = "", Статус = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		Если глЗначениеПеременной("ВыводитьСлужебнуюИнформацию") = Истина Тогда
			СообщитьИнформацию(ТекстСообщения, Заголовок, Статус);
		КонецЕсли;
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьИнформацию()

// Получает первичную информацию об ошибке
// Параметры:
//	ИнформацияОбОшибке - информация об ошибке
// Возвращает:
//	Информацию об ошибке, которая является первопричиной возникновения переданной ИнформацияОбОшибке
//  Если ошибка первичная, то возвращается сама ошибка, переданная в качестве параметра
Функция ПолучитьПричинуОшибки(ИнформацияОбОшибке) Экспорт
	ПричинаОшибки = ИнформацияОбОшибке.Причина;
	Если ПричинаОшибки = НеОпределено Тогда
		Возврат ИнформацияОбОшибке;
	КонецЕсли;
	Пока ПричинаОшибки.Причина <> НеОпределено Цикл
		ПричинаОшибки = ПричинаОшибки.Причина;
	КонецЦикла;
	Возврат ПричинаОшибки;
	
КонецФункции

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте вывобит сообщение в обработку комментирования
// на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения  - строка, текст сообщения.
//					  Строка может содержать символы %%, которые при формировании 
//					  сообщения заменяются на представления элементов расшифровки
//  Отказ           - булево, признак отказа (необязательный).
//  Заголовок	    - Заголовок сообщения, для вывода сообщения если работа на сервере или внешнее соединение
//	Расшифровки 	- массив расшифровок для переданного ТекстСообщения
//					  Представляет собой массив структур с полями Представление и Расшифровка
//					  Поле Представление - текст, дополняющий ТекстСообщения
//					  Поле Расшифровка - действие, выполняемое по расшифровке
//
Процедура ВывестиИнформациюОбОшибке(Знач ТекстСообщения, Отказ = Истина, Заголовок = "", ВидСообщения = Неопределено, Расшифровки = Неопределено) Экспорт
	
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#ИначеЕсли Клиент Тогда
	
	    Если ВидСообщения = Неопределено Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
		КонецЕсли;
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Обработка.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровки);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ 

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата", ДокументОбъект.Дата);
	
	ТипДокумента = ТипЗнч(ДокументОбъект);
	
	МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
		СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", СокрЛП(ДокументОбъект));
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
	
	Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;
	 		
	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	//
	КолонкиТаблицы = ТаблицаДвижений.Колонки;
	
	//
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	ИзмеренияСостТипаСтр = "";
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаИзм.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаИзм.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРек.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРек.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРек.Имя;
			КонецЕсли; 
			
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРес.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРес.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРес.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
	Если ИзмеренияСостТипаСтр <> "" Тогда
		ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);
	КонецЕсли;
	
	ТипЧисло = Тип("Число");
	ТипСтрока = Тип("Строка");
	ТипДата = Тип("Дата");
	
	ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;

	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Движение = НаборДвижений.Добавить();
		ЗаполнитьЗначенияСвойств(Движение, СтрокаДвижения, ,ИзмеренияСостТипаСтр);
		
		Если ВидДвижения <> Неопределено Тогда
			Движение.ВидДвижения = ВидДвижения;
		КонецЕсли;
		
		Если ЕстьПериод И НЕ СтрокаДвижения.Период = '00010101000000' Тогда
			Движение.Период = СтрокаДвижения.Период;
		ИначеЕсли НаборДвижений.мПериод <> Неопределено Тогда
			Движение.Период = НаборДвижений.мПериод;
		КонецЕсли; 
		Движение.Активность = Истина;
		
		Для Каждого КлючИЗначение ИЗ ИзмеренияСостТипа Цикл
			ЗначениеВКолонке = СтрокаДвижения[КлючИЗначение.Ключ];
			
			Если ЗначениеВКолонке = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗначенияВКолонке = ТипЗнч(ЗначениеВКолонке);
			
			Если ТипЗначенияВКолонке = ТипЧисло Тогда
				Если ЗначениеВКолонке = 0 Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипСтрока Тогда
				Если ЗначениеВКолонке = "" Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипДата Тогда
				Если ЗначениеВКолонке = '00010101000000' Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ЗначениеВКолонке.Пустая() Тогда
				Продолжить;
			КонецЕсли;
			
			Движение[КлючИЗначение.Ключ] = ЗначениеВКолонке;
			
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Возвращает рабочую дату
//
// Возвращаемое значение:
//   Дата - рабочая дата
//
Функция ПолучитьРабочуюДату() Экспорт

#Если Клиент Тогда
	Дата = РабочаяДата;
#Иначе
	Дата = ТекущаяДата();
#КонецЕсли

	Возврат Дата;

КонецФункции // ПолучитьРабочуюДату()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	Для Поз = 1 По СтрДлина(Источник) Цикл
		ТекКод = КодСимвола(Источник, Поз);
		
		Если ТекКод >= КодСимвола("0") И ТекКод <= КодСимвола("9") Тогда
			ТекКод = ТекКод - КодСимвола("0");
		ИначеЕсли ТекКод >= КодСимвола("a") И ТекКод <= КодСимвола("f") Тогда
			ТекКод = ТекКод +10 - КодСимвола("a");
		ИначеЕсли ТекКод >= КодСимвола("A") И ТекКод <= КодСимвола("F") Тогда
			ТекКод = ТекКод +10 - КодСимвола("A");
		КонецЕсли;
		
		Результат = Результат * 16 + ТекКод;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВтройСимвол		= Источник % 16;
	
	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СЧЕТАМИ И СУБКОНТО

// Функция возвращает структуру с параметрами учетной политики на заданную дату.
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация = Неопределено, Учет = "Упр", СообщатьОбОшибке = Истина, Заголовок = "") Экспорт	
	
	СтруктураУчПолитика = Новый Структура;
			
	Если Учет <> "Упр" И НЕ ЗначениеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;
		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;

	Если Учет = "Нал" Тогда
		УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаПоНалоговомуУчету");
		
	ИначеЕсли Учет = "Упр" Тогда
		УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаПоУправленческомуУчету");
		
	Иначе
		УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаПоБухгалтерскомуУчету");
	КонецЕсли; 
		
	Если Учет = "Упр" Тогда
		
		Если УчетнаяПолитика.Количество() = 0 Тогда
			Отказ = Истина;
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке(НСтр("ru='Не указаны параметры учетной политики управленческого учета на ';uk='Не вказані параметри облікової політики управлінського обліку на '") + Формат(КонДата, "ДЛФ=DD"), Отказ, Заголовок);
			КонецЕсли;	
			Возврат СтруктураУчПолитика;	
		Иначе
				
			Номер = 0;
			ФлагОтказа = Истина;
			Для НомерСтроки = 1 По УчетнаяПолитика.Количество() Цикл
				
				Строка = УчетнаяПолитика.Получить(НомерСтроки - 1);
				Если Строка.Период <= КонДата Тогда
					Номер = НомерСтроки;
					ФлагОтказа = Ложь;
						
				Иначе 
					Прервать;
				КонецЕсли;
			КонецЦикла;
				
			Если Номер <> 0 Тогда
				Строка = УчетнаяПолитика.Получить(Номер - 1);
				Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
					СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				КонецЦикла;
					
			КонецЕсли;
				
		КонецЕсли;
		
	Иначе
		
		УчетнаяПолитикаОрганизации = УчетнаяПолитика.НайтиСтроки(Новый Структура("Организация", Организация));
		
		Если УчетнаяПолитикаОрганизации.Количество() = 0 Тогда
			Отказ = Истина;
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке(НСтр("ru='Не указаны параметры учетной политики общей для регламентированного учета или для ';uk='Не вказані параметри облікової політики загальної для регламентованого обліку або для '") + ?(Учет = "Нал", "налогового", "бухгалтерского") +НСтр("ru=' учета (';uk=' обліку ('")+СокрЛП(Организация)+НСтр("ru=') на ';uk=') на '") + Формат(КонДата, "ДЛФ=DD"), Отказ, Заголовок);
			КонецЕсли;
			Возврат СтруктураУчПолитика;	
		Иначе
				
			Номер = 0;
			ФлагОтказа = Истина;
			Для НомерСтроки = 1 По УчетнаяПолитикаОрганизации.Количество() Цикл
					
				Строка = УчетнаяПолитикаОрганизации.Получить(НомерСтроки - 1);
				Если Строка.Период <= КонДата Тогда
					Номер = НомерСтроки;
					ФлагОтказа = Ложь;
						
				Иначе 
					Прервать;
				КонецЕсли;
			КонецЦикла;
				
			Если Номер <> 0 Тогда
				Строка = УчетнаяПолитикаОрганизации.Получить(Номер - 1);
				Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
					СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				КонецЦикла;
					
			КонецЕсли;
				
		КонецЕсли;
		
	КонецЕсли;
		
	Если ФлагОтказа = Истина Тогда
		Отказ = Истина;
		Если СообщатьОбОшибке Тогда
			Если Учет = "Упр" Тогда
				СообщитьОбОшибке(НСтр("ru='Не указаны параметры учетной политики управленческого учета на ';uk='Не вказані параметри облікової політики управлінського обліку на '") + Формат(КонДата, "ДЛФ=DD"), Отказ, Заголовок);
			Иначе
				СообщитьОбОшибке(НСтр("ru='Не указаны параметры учетной политики общей для регламентированного учета или для ';uk='Не вказані параметри облікової політики загальної для регламентованого обліку або для '") + ?(Учет = "Нал", "налогового", "бухгалтерского") +НСтр("ru=' учета (';uk=' обліку ('")+СокрЛП(Организация)+НСтр("ru=') на ';uk=') на '") + Формат(КонДата, "ДЛФ=DD"), Отказ, Заголовок);
			КонецЕсли;
		КонецЕсли;	
		Возврат СтруктураУчПолитика;
	КонецЕсли; 
		
	Возврат СтруктураУчПолитика;
		
КонецФункции // ПолучитьПараметрыУчетнойПолитики()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии) Экспорт

	КоличествоТочек = 0;
	ДлинаОписанияНомераРелиза = 0;

	Для х = 1 По СтрДлина(НомерВерсии) Цикл

		Если Сред(НомерВерсии, х, 1) = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;

		Если КоличествоТочек = 3 Тогда
			ДлинаОписанияНомераРелиза = х - 1;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Лев(НомерВерсии, ДлинаОписанияНомераРелиза);

КонецФункции // ПолучитьНомерРелиза()

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПЕРЕМЕННЫМИ

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить

// Разбивает строку (не разрывая слов) на подстроки указанной длинны, 
//							строки дополняются пробелами, переводы строк удаляются.
// Параметры:
//  ТекстСтроки  - Строка, которую необходимо разбить на подстроки.
//                 
//  МассивДлинСтрок  - Массив длин строк, если в результирующей строке оказалось подстрок больше.
//                     Чем количество указанных длин, то все "лишние" строки выравниваются по последнему
//                     значению длинны строки.
// Возвращаемое значение:
//   Строка   - разбитая на подстроки указанной длинны.
//
Функция РазбитьСтрокуНаПодСтроки(Знач ТекстСтроки, МассивДлинСтрок) Экспорт

	ВозвращаемаяСтрока = "";
	
	РазделителиСлов = " .,:;?!%\<>+-*/=_" + Символы.ПС;
	
	ТекстСтроки = СокрЛП(ТекстСтроки);
	
	// Обыграем случай, когда у нас многострочная строка.
	Если СтрЧислоСтрок(ТекстСтроки) > 1 Тогда
	
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ТекстСтроки) Цикл
			
			НовыйМассивДлинСтроки = Новый Массив;
			
			Если НомерПодстроки = 1 Тогда
			
				НачальнаяГраница = 0;
			
			Иначе
				
				Если СтрЧислоСтрок(ВозвращаемаяСтрока) > МассивДлинСтрок.ВГраница() Тогда
				
					НачальнаяГраница = МассивДлинСтрок.ВГраница();
					
				Иначе
					
					НачальнаяГраница = СтрЧислоСтрок(ВозвращаемаяСтрока);
				
				КонецЕсли; 
			
			КонецЕсли; 
			
			Для ИндексСтроки = НачальнаяГраница По МассивДлинСтрок.ВГраница() Цикл
			
				НовыйМассивДлинСтроки.Добавить(МассивДлинСтрок[ИндексСтроки]);
			
			КонецЦикла; 
		
			ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + РазбитьСтрокуНаПодСтроки(СтрПолучитьСтроку(ТекстСтроки, НомерПодстроки), НовыйМассивДлинСтроки);
		
		КонецЦикла; 
		
	Иначе
		
		ДлинаСтроки = МассивДлинСтрок[0];
		
		// Если длина строки меньше или равна нужной длине - просто вернем ее.
		Если СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
		
			ВозвращаемаяСтрока = ТекстСтроки; 
			
		Иначе
			
			// Заменим все разделители символом _, для удобства анализа.
			ТестируемаяСтрока = ТекстСтроки;
			
			Для НомерРазделителя = 1 По СтрДлина(РазделителиСлов)  Цикл
				
				РазделительСлов = Сред(РазделителиСлов, НомерРазделителя, 1);
				
				ТестируемаяСтрока = СтрЗаменить(ТестируемаяСтрока, РазделительСлов, "_");
			
			КонецЦикла; 
			
			// Найдем первый разделитель
			Разрыв = Найти(ТестируемаяСтрока, "_");
			
			ИндексМассиваДлинСтрок = 0;
			
			// Обрабатываем строку пока она не закончится.
			Пока СтрДлина(ТекстСтроки) > 0 Цикл
				
				Если ИндексМассиваДлинСтрок <= МассивДлинСтрок.ВГраница() Тогда
				
					ДлинаСтроки = МассивДлинСтрок[ИндексМассиваДлинСтрок];
				
				Иначе
				
					ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
				КонецЕсли; 
				
				// Если разрыв больше чем нужная длина
				// если разрывов больше нет
				// и частный случай, когда есть разрыв - пробел в самом конце строки нужной длины
				// или длина оставшейся строки меньше или равна нужной длине.
				Если Разрыв >= ДлинаСтроки ИЛИ Разрыв = 0 ИЛИ Сред(ТекстСтроки, ДлинаСтроки + 1, 1) = " " ИЛИ СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
				
					ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, ДлинаСтроки));
					
					ТекстСтроки = СокрЛП(Сред(ТекстСтроки, ДлинаСтроки + 1));
					
					ТестируемаяСтрока = Сред(ТестируемаяСтрока, ДлинаСтроки + 1);
					
					Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
					КонецЕсли; 
					
					ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
					Разрыв = Найти(ТестируемаяСтрока, "_");
				
				Иначе 
					
					НовыйРазрыв = Найти(Сред(ТестируемаяСтрока, Разрыв + 1), "_");
					
					// Есть еще один разрыв и он вместе с предыдущим меньше или равен длине строки.
					Если НовыйРазрыв > 0 И Разрыв + НовыйРазрыв <= ДлинаСтроки Тогда
						
						Разрыв = Разрыв + НовыйРазрыв;
						
					Иначе
						
						// больше разрывов нет
						// или он вместе с предыдущим больше нужной длины
						ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, Разрыв));
						
						ТекстСтроки = СокрЛП(Сред(ТекстСтроки, Разрыв + 1));
						
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, Разрыв + 1);
						
						Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
							ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
						КонецЕсли; 
					
						ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
						Разрыв = Найти(ТестируемаяСтрока, "_");
						
					КонецЕсли;
				
				КонецЕсли;
				
			КонецЦикла; 
				
		КонецЕсли; 
	
	КонецЕсли;
	
	Если СтрЧислоСтрок(ВозвращаемаяСтрока) > 1 Тогда
		
		ВыровненнаяСтрока = "";
		
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ВозвращаемаяСтрока) - 1 Цикл
			
			ВыравниваемаяСтрока = СтрПолучитьСтроку(ВозвращаемаяСтрока, НомерПодстроки);
			
			Если НомерПодстроки - 1 <= МассивДлинСтрок.ВГраница() Тогда
				
				ДлинаСтроки = МассивДлинСтрок[НомерПодстроки - 1];
				
			Иначе
				
				ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
			КонецЕсли; 
				
			Для НомерПозицииВСтроке = СтрДлина(ВыравниваемаяСтрока) + 1 По ДлинаСтроки Цикл
			
				ВыравниваемаяСтрока = ВыравниваемаяСтрока + " ";
			
			КонецЦикла; 
			
			ВыровненнаяСтрока = ВыровненнаяСтрока + ?(ПустаяСтрока(ВыровненнаяСтрока), "", Символы.ПС) + ВыравниваемаяСтрока;
		
		КонецЦикла;
		
		ВозвращаемаяСтрока = ВыровненнаяСтрока + Символы.ПС + СтрПолучитьСтроку(ВозвращаемаяСтрока, СтрЧислоСтрок(ВозвращаемаяСтрока));
		
	КонецЕсли; 
	
	Возврат ВозвращаемаяСтрока;

КонецФункции // РазбитьСтрокуПоСтрочно()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ПОГРЕШНОСТЕЙ ОКРУГЛЕНИЯ

// Выполняет округление числовых значений с накоплением погрешностей округления, образовавшихся
//		в результате предыдущих вызовов функции
//
// Параметры
//  Число 		– Число. Округляемое значение
//  Точность	– Число. Точность округления
//	Погрешность	- Число. Переменная, в которой накапливается погрешность с предыдущих вызовов
//
// Возвращаемое значение:
//   Число   – округленное значение
//
Функция ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность = 0, 
	               СоответствиеПогрешностей = Неопределено, Ключ = Неопределено)  Экспорт 

	Если НЕ СоответствиеПогрешностей = Неопределено И ЗначениеЗаполнено(Ключ) Тогда
	
		// считываем погрешность округления, накопленную ранее при расчетах
		Погрешность = СоответствиеПогрешностей[Ключ];
		// погрешности округления еще нет -- первая сумма
		Если Погрешность = Неопределено Тогда
			Погрешность = 0;
		КонецЕсли;
		// округлим с учетом погрешности
		Округленное = ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность);
		// сохраним погрешность округления
		СоответствиеПогрешностей.Вставить(Ключ, Погрешность);
	
	Иначе
		
		Если Число = 0 Тогда
			Возврат 0;
		КонецЕсли; 
	
		// выравнивание разрядности
		Число = Окр(Число, 27, ?(Число<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// сумма с учетом погрешности предыдущих вычислений
		Округляемое = Число + Погрешность;

		// для отрицательного числа меняем направление округления, чтобы избежать ошибки Окр(-0.5) = -1
		Округленное	= Окр(Округляемое, Точность, ?(Округляемое<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// рассчитаем новую погрешность округления
		Погрешность	= Округляемое - Округленное;
		
	КонецЕсли;
	
	Возврат Округленное;

КонецФункции // ОкруглитьСУчетомПогрешности()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если ПараметрыСеанса.ИспользованиеРИБ Тогда
		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	КонецЕсли;
	
КонецПроцедуры

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура СообщитьИнформацияОПрефиксации() Экспорт
	
	Если ПустаяСтрока(ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы) Тогда
		
		Сообщить(НСтр("ru='Для задействования механизма установки префиксов объектов необходимо установить константу ""Префикс узла для распределенной информационной базы"" "
" и перезапустить текущий сеанс работы 1С:Предприятия.';uk='Для залучення механізму встановлення префіксів об''єктів необхідно встановити константу ""Префікс вузла для розподіленої інформаційної бази"" "
" і запустити знову поточний сеанс роботи 1С:Підприємства.'"));
		Сообщить(НСтр("ru='Текущее значение префикса: ';uk='Поточне значення префікса: '") + ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы);
		
	КонецЕсли;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML

// Функция осуществляет построение дерева XML.
//
// Параметры
//  XML             - <ЧтениеXML>
//                  - Объект, при помощи которого осуществляется чтение
//                    файла отчета.
//
//  Дерево          - <Структура>
//                  - Дерево XML.
//
//  ПервыйВызов     - <Булево>
//                  - Служебный параметр.
//
// Возвращаемое значение:
//  <Булево>        - Результат выполнения.
//
Функция ПостроитьДеревоXML(XML, Дерево, ПервыйВызов = Истина) 

	Результат = Истина;
	Имя       = "";
	Врем      = Неопределено;
	Врем2     = Неопределено;
	Врем3     = Неопределено;

	Если ПервыйВызов Тогда
		Дерево = Новый Структура();
	КонецЕсли;

	Если XML.Прочитать() Тогда
		Если XML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Имя  = XML.ЛокальноеИмя;
			Врем = Новый Структура();
			Пока ПостроитьДеревоXML(XML, Врем, Ложь) Цикл
			КонецЦикла;
			Пока XML.Имя <> Имя Цикл
				Если XML.ТипУзла = ТипУзлаXML.Текст Тогда
					Врем = XML.Значение;
				КонецЕсли;
				Если Не XML.Прочитать() Тогда
					Результат = Ложь;
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
			Дерево.Свойство(Имя, Врем2);
			Если Врем2 = Неопределено Тогда
				Врем2 = Врем;
			Иначе
				Если ТипЗнч(Врем2) = Тип("Массив") Тогда
					Врем2.Добавить(Врем);
				Иначе
					Врем3 = Новый Массив();
					Врем3.Добавить(Врем2);
					Врем3.Добавить(Врем);
					Врем2 = Врем3;
				КонецЕсли;
			КонецЕсли;
			Дерево.Вставить(Имя, Врем2);
		Иначе
			Результат = Ложь;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПостроитьДеревоXML()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

// Функция разбирает строку вида
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//  МетаданныеОбъекта - Объект метаданных
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если МетаданныеОбъекта <> Неопределено Тогда
		Структура.Вставить("Метаданные", МетаданныеОбъекта);
	Иначе
		Если Структура.ТипОбъекта = "Документ" Тогда
			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
		Иначе
			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ

Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	// Значение в КЭШе не нашли, получим значение из БД
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущийПользователь;
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоПерсоналу") Тогда
		НайденноеЗначение = ЗаполнениеУчетнойПолитикиПоПерсоналу();
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глУчетнаяПолитикаПоПерсоналуОрганизации") Тогда
		НайденноеЗначение = ЗаполнениеУчетнойПолитикиПоПерсоналуОрганизации();		

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКоличествоСекундОпросаОбмена") Тогда	
		НайденноеЗначение = ПроцедурыОбменаДанными.ПолучитьКоличествоСекундОпросаЗапускаОбменаДанными();
		
		
		
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВалютаРегламентированногоУчета") Тогда	
		НайденноеЗначение = Константы.ВалютаРегламентированногоУчета.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВалютаУправленческогоУчета") Тогда	
		НайденноеЗначение = Константы.ВалютаУправленческогоУчета.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ИспользоватьСерииНоменклатуры") Тогда	
		НайденноеЗначение = Константы.ИспользоватьСерииНоменклатуры.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УказаниеСкладовВТабличнойЧастиДокументов") Тогда	
		НайденноеЗначение = Константы.УказаниеСкладовВТабличнойЧастиДокументов.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ПроведениеДокументовНаСервере") Тогда	
		НайденноеЗначение = Константы.ПроведениеДокументовНаСервере.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетПоВсемОрганизациям") Тогда	
	//	НайденноеЗначение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "УчетПоВсемОрганизациям");
	//	
	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетПоВсемОрганизациям") Тогда	
	//	НайденноеЗначение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "УчетПоВсемОрганизациям");
	
	НайденноеЗначение = Истина;
	
#Если Клиент Тогда
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("КэшСтратегииАвтонумерации") Тогда	
		НайденноеЗначение = Новый Соответствие;		
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глСоответствиеТекстовЭлектронныхПисем") Тогда	
		НайденноеЗначение = Новый Соответствие;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоПолученияОтправкиЭлектронныхПисем") Тогда	
		НайденноеЗначение = Обработки.АвтоПолучениеОтправкаЭлектронныхПисем.ПолучитьФорму();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глЗапрашиватьПодтверждениеПриЗакрытии") Тогда	
		НайденноеЗначение = Истина;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоОбменДанными") Тогда	
		НайденноеЗначение = ПроцедурыОбменаДанными.ВыполнитьИнициализациюАвтообменаПриНачалеРаботы();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВыводитьСлужебнуюИнформацию") Тогда
		НайденноеЗначение = ПолучитьВыводитьСлужебнуюИнформацию();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаСообщений") Тогда
		НайденноеЗначение = Обработки.СообщенияВыполняемыхДействий.Создать();		
	
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКомпонентаСклоненияФИО") Тогда
		Возврат Неопределено;
			
#КонецЕсли


	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ДатаНачалаПереходаНаСтандартIBAN") Тогда
		
		// константа введена ТОЛЬКО для возможности влиять на значение параметра с использованием внешней обработки.
		НайденноеЗначение = Константы.ДатаНачалаПереходаНаСтандартIBAN.Получить();
		Если НЕ ЗначениеЗаполнено(НайденноеЗначение) Тогда
			НайденноеЗначение = '20190805';
		КонецЕсли;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ДатаОкончанияПереходаНаСтандартIBAN") Тогда
		
		// константа введена ТОЛЬКО для возможности влиять на значение параметра с использованием внешней обработки.
		НайденноеЗначение = Константы.ДатаОкончанияПереходаНаСтандартIBAN.Получить();
		Если НЕ ЗначениеЗаполнено(НайденноеЗначение) Тогда
			НайденноеЗначение = '20191031';
		КонецЕсли;

	Иначе
		
		ЗначениеИзПараметраСеанса = ПараметрыСеанса[Сред(ИмяПараметра, 3)];
		Если ТипЗнч(ЗначениеИзПараметраСеанса) = Тип("ХранилищеЗначения") Тогда
			 Возврат ЗначениеИзПараметраСеанса.Получить();
		 Иначе
			 Возврат ЗначениеИзПараметраСеанса;
		КонецЕсли; 
		
		//СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
		//ВызватьИсключение СтрокаИсключения;
		
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

Процедура УстановитьЗначениеПеременной(ИмяПараметра, Кэш, ЗначениеПараметра, ОбновлятьВоВсехКэшах = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	КонецЕсли;
	
	Если Кэш.Свойство(ИмяПараметра) Тогда
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
	КонецЕсли;
	
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		Если ОбновлятьВоВсехКэшах Тогда
			КэшНаСервере = ПараметрыСеанса.ОбщиеЗначения.Получить();
			КэшНаСервере.Вставить(ИмяПараметра, ЗначениеПараметра);
			ПараметрыСеанса.ОбщиеЗначения = Новый ХранилищеЗначения(КэшНаСервере);
		КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры

// Функция определяет наличие клиентских подключений к базе других пользователей
Функция ЕстьДругиеПользователиВБазе() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда			
			Возврат Истина;						
		КонецЕсли;		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет параметр запуска на предмет вывода служебной информации
Функция ПолучитьВыводитьСлужебнуюИнформацию()
	#Если Клиент Тогда
		Если Найти(ВРег(ПараметрЗапуска), ВРег("test")) > 0  ИЛИ 
			Найти(ВРег(ПараметрЗапуска), ВРег("ВыводитьСлужебнуюИнформацию")) > 0  Тогда
			
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	#Иначе
		Возврат Ложь;
	#КонецЕсли
КонецФункции

#Если Клиент Тогда
	
// Показывает таблицу значений в отдельной форме, в немодальном окне
//
// Параметры
//  ТЗ  – ТаблицаЗначений – Таблица значений, которую необходимо показать
//
Процедура ПоказатьТаблицуЗначений(ТЗ, Заголовок = "", Модально = Ложь) Экспорт
	Обработки.ПросмотрТаблицыЗначений.Создать().ПоказатьТаблицуЗначений(ТЗ, Заголовок, Модально);
КонецПроцедуры // ПоказатьТаблицуЗначений(ТЗ)

// Показывает дерево значений в отдельной форме, в немодальном окне
//
// Параметры
//  ТЗ  – ТаблицаЗначений – Таблица значений, которую необходимо показать
//
Процедура ПоказатьДеревоЗначений(ДЗ, Заголовок = "") Экспорт
	Обработки.ПросмотрТаблицыЗначений.Создать().ПоказатьДеревоЗначений(ДЗ, Заголовок);
КонецПроцедуры // ПоказатьДеревоЗначений(ТЗ)

#КонецЕсли

// Возвращает таблицу значений из временной таблицы и (по небходимости) показывает ее в модальном окне
// Варианты ситаксиса
//  МенеджерВременныхТаблиц,ИмяВременнойТаблицы
//  Запрос,ИмяВременнойТаблицы
//  Запрос,""
Функция ПоказатьВременнуюТаблицу(ИсходныйЗапрос, ИмяВременнойТаблицы = "", Показать = Ложь) Экспорт
	
	Запрос = Новый Запрос;
	Если ТипЗнч(ИсходныйЗапрос) = Тип("Запрос") Тогда
		Запрос.МенеджерВременныхТаблиц = ИсходныйЗапрос.МенеджерВременныхТаблиц;
	ИначеЕсли ТипЗнч(ИсходныйЗапрос) = Тип("МенеджерВременныхТаблиц") Тогда
		Запрос.МенеджерВременныхТаблиц = ИсходныйЗапрос;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
	Если ИмяВременнойТаблицы <> "" Тогда
		Запрос.Текст = "ВЫБРАТЬ
		|	*
		|ИЗ
		|	"+ИмяВременнойТаблицы+"
		|";
	ИначеЕсли ТипЗнч(ИсходныйЗапрос) = Тип("Запрос") Тогда
		ТекстЗапроса = ИсходныйЗапрос.Текст;
		Для Счетчик = 1 По СтрЧислоСтрок(ТекстЗапроса) Цикл
			ТекСтрока = СтрПолучитьСтроку(ТекстЗапроса, Счетчик);
			Позиция = Найти(ТекСтрока,"ПОМЕСТИТЬ");
			Если Позиция > 0 Тогда
				ТекСтрока = СтрЗаменить(ТекСтрока,"ПОМЕСТИТЬ","");
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Запрос.Текст = "ВЫБРАТЬ
		|	*
		|ИЗ
		|	"+СокрЛП(ТекСтрока)+"
		|";
	Иначе
		Возврат Ложь;
	КонецЕсли;	
	
	РезультатЗапроса = Запрос.Выполнить();
	
	#Если Клиент Тогда
	Если Показать Тогда	
		ПоказатьТаблицуЗначений(РезультатЗапроса.Выгрузить(), "Временная таблица " + ИмяВременнойТаблицы,Показать);
	КонецЕсли;	
	#КонецЕсли

    Возврат РезультатЗапроса.Выгрузить();
	
КонецФункции // ПоказатьВременнуюТаблицу()


// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является голвной
//
// Параметры
//  Организация – СправочникСсылка.Организации
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ГоловнаяОрганизация
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	Выборка = Запрос.Выполнить().Выбрать();
	Если Не Выборка.Следующий() Тогда
		Возврат Справочники.Организации.ПустаяСсылка()
	КонецЕсли;
	Если Организация.Пустая() или Выборка.ГоловнаяОрганизация.Пустая() Тогда
		Возврат Организация;
	Иначе
		Возврат Выборка.ГоловнаяОрганизация;
	КонецЕсли;
КонецФункции // ГоловнаяОрганизация()

// Функция формирует представление периода по дате начала и дате окончания.
//
// Параметры
//  ДатаНачала	   – Дата – дата начала периода.
//  ДатаОкончания  – Дата – дата окончания периода.
//  ДатаНачала	   – Булево – признак того, что описание периода будет сформирован 
//					 без указания чисел месяца.
//
// Возвращаемое значение:
//   Строка   – строковое представление периода.
//
Функция ОписаниеПериода(ДатаНачала, ДатаОкончания, МесяцКратко = Истина, СДатами = Истина) Экспорт
	
	КодЯзыка = Локализация.ПолучитьЯзыкФормированияПечатныхФорм(УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "РежимФормированияПечатныхФорм"));

	ЧислоНачала		= День(ДатаНачала);
	ЧислоОкончания	= День(ДатаОкончания);
	Если МесяцКратко Тогда
		ОписаниеМесяцаГода = Лев(Формат(ДатаНачала,   "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ=MMMM"),3) + " " + Формат(ДатаНачала,    "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ=гг");
		ОписаниеМесяца2    = Лев(Формат(ДатаОкончания,"Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ = 'MMMM'"),3) + " " + Формат(ДатаОкончания, "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ = 'гг'");
	Иначе
		Месяц	= Формат(ДатаНачала, "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+";ДФ=MMMM");
		ОписаниеМесяцаГода = Месяц + " " + Формат(ДатаНачала,    "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ = 'гг'");
		Месяц	= Формат(ДатаОкончания, "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+";ДФ=MMMM");
		ОписаниеМесяца2    = Месяц + " " + Формат(ДатаОкончания, "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ = 'гг'");
	КонецЕсли;
	
	Если Месяц(ДатаНачала) <> Месяц(ДатаОкончания) Тогда  
		
		Если (ДатаНачала = НачалоМесяца(ДатаНачала)) Или Не СДатами Тогда
			Месяц	= Формат(ДатаНачала, "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+";ДФ=MMMM");
			Перваяполовинадат = Месяц + " " + Формат(ДатаНачала,    "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ = 'гг'");
		Иначе
			Перваяполовинадат = "" + ЧислоНачала + " " + ОписаниеМесяцаГода; 
		КонецЕсли;
		
		Если (ДатаОкончания = КонецМесяца(ДатаОкончания)) Или Не СДатами Тогда
			Месяц	= Формат(ДатаОкончания, "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+";ДФ=MMMM");
			ВтораяПоловинаДат = Месяц + " " + Формат(ДатаОкончания,    "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ = 'гг'");
		Иначе
			ВтораяПоловинаДат = "" + ЧислоОкончания + " " + ОписаниеМесяца2;
		КонецЕсли;
		
		Возврат Перваяполовинадат + "-" + ВтораяПоловинаДат;
		
	Иначе
		
		Если ДатаНачала = НачалоМесяца(ДатаНачала) И ДатаОкончания + 86399 = КонецМесяца(ДатаОкончания) Или Не СДатами Тогда
			Месяц	= Формат(ДатаНачала, "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+";ДФ=MMMM");
			Возврат Месяц + " " + Формат(ДатаНачала,    "Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)+"; ДФ = 'гг'");
		ИначеЕсли ЧислоНачала = ЧислоОкончания Тогда
			Возврат "" + ЧислоНачала + " " + ОписаниеМесяцаГода;
		Иначе
			Возврат "" + ЧислоНачала + "-" + ЧислоОкончания + " " + ОписаниеМесяцаГода;
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции	// ОписаниеПериода 

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт
	
	Если МассивКоэф.Количество() = 0 Или ИсхСумма = 0 Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);
		
		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;
		
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[К];
	КонецЦикла;
	
	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	Возврат МассивСумм;
	
КонецФункции // РаспределитьПропорционально()

// Процедура устанавливает номер документа.
//
// Параметры:
//  ДокументОбъект  - ДокументОбъект. Экземпляр документа, которому 
//                    необходимо присвоить новый номер
//
Процедура УстановитьНомерДокумента(ДокументОбъект) Экспорт

	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	 Если МетаданныеДокумента.Реквизиты.Найти("Организация") = Неопределено 
	 Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		ДокументОбъект.УстановитьНовыйНомер("00");

	Иначе

		ДокументОбъект.УстановитьНовыйНомер(ДокументОбъект.Организация.Префикс);

	КонецЕсли;

КонецПроцедуры // УстановитьНомерДокумента()

// Процедура удаления существующих движений документа при перепроведении (отмене проведения)
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, ОчищатьКоллекциюДвижений = ИСТИНА, РегистрыКБезусловномуУдалению = Неопределено) Экспорт
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ПолныеПрава.ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	ТаблицаДвижений.Колонки.Добавить("НаборЗаписей");
	ТаблицаДвижений.Колонки.Добавить("БезусловноеУдаление", Новый ОписаниеТипов("Булево"));
		
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		// имя регистра передается как значение, полученное с помощью
		// функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));
		
		Если (НЕ РегистрыКБезусловномуУдалению = Неопределено) И РегистрыКБезусловномуУдалению.Свойство(ИмяРегистра) Тогда
			СтрокаДвижения.БезусловноеУдаление = Истина;
			Набор = ИмяРегистра;
			
		Иначе
			ЕСли ТипРегистра = "РегистрНакопления" Тогда
				МетаданныеНабора = Метаданные.РегистрыНакопления[ИмяРегистра];
				Набор = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
				МетаданныеНабора = Метаданные.РегистрыБухгалтерии[ИмяРегистра];
				Набор = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
				МетаданныеНабора = Метаданные.РегистрыСведений[ИмяРегистра];
				Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
				
			ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
				МетаданныеНабора = Метаданные.РегистрыРасчета[ИмяРегистра];
				Набор = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
				
			КонецЕсли;
				
			Если НЕ ПравоДоступа("Изменение", МетаданныеНабора) Тогда
				// отсутствуют права на всю таблицу регистра
				СообщитьОбОшибке(НСтр("ru='Нарушение прав доступа';uk='Порушення прав доступу'"), Отказ, СтрокаДвижения.Имя);
				Возврат;
			КонецЕсли;
				
			Набор.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);
		КонецЕсли;
		// набор не записывается сразу, чтобы не откатывать транзакцию, если впоследствии
		// выяснится, что на один из регистров не хватает прав.
		СтрокаДвижения.НаборЗаписей = Набор;
		
	КонецЦикла;
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Если СтрокаДвижения.БезусловноеУдаление Тогда
			ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(СтрокаДвижения.НаборЗаписей, ДокументОбъект.Ссылка);
			
		Иначе
			Попытка
				СтрокаДвижения.НаборЗаписей.Записать();
			Исключение
				// возможно «сработал» RLS или механизм даты запрета изменения
				СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СтрокаДвижения.Имя);
				ВызватьИсключение "Операция не выполнена";
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
	Если ОчищатьКоллекциюДвижений Тогда
		Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
			Если Движение.Количество() > 0 Тогда
				Движение.Очистить();
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
		
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") ИЛИ
			  ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") или ТипОбъекта = Тип("СправочникОбъект.СотрудникиОрганизаций") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
		
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"");

КонецФункции


///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПЕРЕЧИСЛЕНИЕМ "ПЕРИОДИЧНОСТЬ"
// Функции не обрабатывают значения "Декада" и "Полугодие"

// Функция возвращает ближайшую дату начала периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаНачалаПериода		– ближайшая дата начала периода планирования
//
Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если НЕ ТипЗнч(ДатаВПериоде)=Тип("Дата") Тогда
		Возврат '00010101';
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат НачалоДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат НачалоНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат НачалоМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат НачалоКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат НачалоГода (ДатаВПериоде);
	Иначе
		Возврат НачалоДня(ДатаВПериоде);
	КонецЕсли;
		
КонецФункции // ДатаНачалаПериода()

// Функция возвращает ближайшую дату окончания периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
//
Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт
							
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат КонецДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат КонецНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат КонецМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат КонецКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат КонецГода (ДатаВПериоде);
	Иначе
		Возврат КонецДня(ДатаВПериоде);
	КонецЕсли;
		
КонецФункции // ДатаКонцаПериода()

// Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт

	Если Смещение = 0 Тогда
		НоваяДатаПериода = ДатаПериода;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		НоваяДатаПериода = НачалоДня(ДатаПериода + Смещение*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода = ДатаПериода + Смещение*7*24*3600;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
		
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
		
	КонецЕсли;

	Возврат НоваяДатаПериода;

КонецФункции // ДобавитьИнтервал()

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде, Периодичность, КодЯзыка = "ru") Экспорт
	
	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ='гггг " + НСтр("ru='""г.""';uk='""р.""'", КодЯзыка) + "'";
		
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ='к"" квартал"" гггг " + НСтр("ru='""г.""';uk='""р.""'", КодЯзыка) + "'";
		
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ='ММММ гггг " + НСтр("ru='""г.""';uk='""р.""'", КодЯзыка) + "'";
		
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ='" + НСтр("ru='""Неделя (""';uk='""Тиждень (""'", КодЯзыка) + "дд.ММ.гггг'";
		
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ='дд.ММ.гггг " + НСтр("ru='""г.""';uk='""р.""'", КодЯзыка) + "'";
	Иначе
		ФорматДаты = "";
		
	КонецЕсли;
	
	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты + ";Л="+ Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка));

	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = "" + НеделяГода(ДатаВПериоде) + НСтр("ru='-ая ';uk='-а '",КодЯзыка) + СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ='"" - ""дд.ММ.гггг)'" + ";Л="+ Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка));
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции // ПолучитьПериодСтрокой()

Процедура УстановитьНовоеЗначение(Параметр, Значение)  Экспорт

	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;

КонецПроцедуры

// Заменяет одни термины, которые используются в коде, другими - уместными в интерфейсе.
// Позволяет иметь один тот же код при разных названиях объектов.
//
// Параметры
//  СтрокаИзИнтерфейса - строка - заголовок колонки, надпись и т.п.
//
// Возвращаемое значение:
//  Строка - новый заголовок колонки, надпись и т.п. 
//
Функция ПреобразоватьСтрокуИнтерфейса(СтрокаИзИнтерфейса) Экспорт 

	Возврат СтрокаИзИнтерфейса

КонецФункции // ПреобразоватьСтрокуИнтерфейса()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	 
	#Если Клиент Тогда
		
		Предупреждение(ТекстСообщения);
	
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	 
КонецПроцедуры // ПредупреждениеОбОшибке()

Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
	
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьПрограмму()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРОВ ЗАПИСЕЙ РЕГИСТРОВ, КОНСТАНТ

// Функция выполняет запись переданного набора записей и 
// формирует сообщение об ошибке, если не удалось записать набор
//
// Параметры
//  НаборЗаписей  - набор записей регистра сведений, который необходимо записать
//
// Возвращаемое значение:
//   Булево   - Истина, когда набор записей записан
//
Функция ЗаписатьНабор(НаборЗаписей) Экспорт

	Попытка
		НаборЗаписей.Записать();
	Исключение
		ВывестиИнформациюОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке()).Описание);
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		Возврат Ложь;
	КонецПопытки;

	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// КОММЕНТАРИИ РАСЧЕТОВ

Функция КомментарийРасчета(	ТекстСообщения, 
							РодительскаяСтрока = НеОпределено,
							ПредставлениеРасшифровкиКомментария = НеОпределено, 
							РасшифровкаКомментария = НеОпределено, 
							ВидСообщения = НеОпределено,
							РаскрытьКомментарий = Истина) Экспорт
	
	#Если Клиент Тогда
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Если ВидСообщения = НеОпределено Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Информация;
		КонецЕсли;
		Если РасшифровкаКомментария <> НеОпределено Тогда
			Расшифровки = Новый Массив;
			// расшифровка сообщений представляет собой массив структур "Представление+Расшифровка"
			Расшифровки.Добавить(Новый Структура("Представление,Расшифровка", ПредставлениеРасшифровкиКомментария, РасшифровкаКомментария));
		Иначе
			Расшифровки = НеОпределено;
		КонецЕсли;
		Возврат Обработка.ДобавитьСообщение(
								ТекстСообщения, 
								ВидСообщения, 
								Расшифровки, 
								РодительскаяСтрока, 
								РаскрытьКомментарий);
	#Иначе
		Сообщить(ТекстСообщения);
	#КонецЕсли
	
КонецФункции

Процедура ОшибкаРасчета(ТекстОшибки) Экспорт
	
	#Если Клиент Тогда
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Обработка.ДобавитьСообщение(ТекстОшибки, Перечисления.ВидыСообщений.Ошибка);
	#Иначе
		Сообщить(ТекстОшибки, СтатусСообщения.Важное);
	#КонецЕсли
КонецПроцедуры

